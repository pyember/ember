"""Chain-of-thought prompting patterns for improved reasoning.

This example demonstrates:
- Basic chain-of-thought (CoT) prompting
- Zero-shot CoT with "Let's think step by step"
- Self-consistency with multiple reasoning paths
- Structured reasoning with explicit steps

Run with:
    python examples/09_practical_patterns/chain_of_thought.py
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, Optional

from ember.api import op


# =============================================================================
# Part 1: Basic Chain-of-Thought
# =============================================================================

@dataclass
class CoTPrompt:
    """A chain-of-thought prompt with question and optional examples."""

    question: str
    examples: List[Dict[str, str]] = field(default_factory=list)

    def format(self) -> str:
        """Format the prompt with examples."""
        parts = []

        for ex in self.examples:
            parts.append(f"Q: {ex['question']}")
            parts.append("A: Let's think step by step.")
            parts.append(ex["reasoning"])
            parts.append(f"Therefore, the answer is {ex['answer']}.")
            parts.append("")

        parts.append(f"Q: {self.question}")
        parts.append("A: Let's think step by step.")

        return "\n".join(parts)


@op
def basic_cot_reasoning(question: str) -> Dict[str, Any]:
    """Apply basic chain-of-thought reasoning."""
    # In production, this would call an LLM
    # Here we demonstrate the pattern structure
    return {
        "question": question,
        "prompt_type": "basic_cot",
        "reasoning": "Step 1: Identify the problem components...",
        "answer": "[Would be generated by LLM]",
    }


def demonstrate_basic_cot() -> None:
    """Show basic chain-of-thought prompting."""
    print("Part 1: Basic Chain-of-Thought")
    print("-" * 50)

    # Create CoT prompt with examples
    prompt = CoTPrompt(
        question="If a train travels 120 miles in 2 hours, what is its average speed?",
        examples=[
            {
                "question": "If 5 apples cost $10, how much does 1 apple cost?",
                "reasoning": "To find the cost of 1 apple, I divide the total cost by "
                "the number of apples. $10 / 5 apples = $2 per apple.",
                "answer": "$2",
            }
        ],
    )

    print("Formatted CoT prompt:")
    print(prompt.format())
    print()

    result = basic_cot_reasoning(prompt.question)
    print(f"Result structure: {result}")
    print()


# =============================================================================
# Part 2: Zero-Shot Chain-of-Thought
# =============================================================================

@dataclass
class ZeroShotCoT:
    """Zero-shot CoT using 'Let's think step by step'."""

    question: str
    trigger: str = "Let's think step by step."

    def format(self) -> str:
        return f"{self.question}\n\n{self.trigger}"


@op
def zero_shot_cot(question: str) -> Dict[str, Any]:
    """Apply zero-shot CoT without examples."""
    prompt = ZeroShotCoT(question=question)
    return {
        "prompt": prompt.format(),
        "method": "zero_shot_cot",
        "reasoning_steps": [
            "Step 1: Parse the problem",
            "Step 2: Identify relevant information",
            "Step 3: Apply reasoning",
            "Step 4: Derive conclusion",
        ],
    }


def demonstrate_zero_shot_cot() -> None:
    """Show zero-shot chain-of-thought."""
    print("Part 2: Zero-Shot Chain-of-Thought")
    print("-" * 50)

    question = "A farmer has 17 sheep. All but 9 run away. How many are left?"

    result = zero_shot_cot(question)
    print(f"Question: {question}")
    print(f"Prompt format:\n{result['prompt']}")
    print(f"\nReasoning steps: {result['reasoning_steps']}")
    print()


# =============================================================================
# Part 3: Self-Consistency
# =============================================================================

@dataclass
class SelfConsistencyConfig:
    """Configuration for self-consistency."""

    num_paths: int = 5
    temperature: float = 0.7
    aggregation: str = "majority_vote"  # majority_vote, weighted


@op
def generate_reasoning_path(
    question: str,
    path_id: int,
) -> Dict[str, Any]:
    """Generate a single reasoning path."""
    # Simulate different reasoning paths
    paths = {
        0: {"reasoning": "Direct calculation: 17 - 8 = 9", "answer": "9"},
        1: {"reasoning": "'All but 9' means 9 remain", "answer": "9"},
        2: {"reasoning": "Count: started with 17, 9 stayed", "answer": "9"},
        3: {"reasoning": "Misread: 17 - 9 = 8", "answer": "8"},  # Intentional error
        4: {"reasoning": "'All but 9' = 9 sheep left", "answer": "9"},
    }
    return {
        "path_id": path_id,
        **paths.get(path_id, paths[0]),
    }


def aggregate_answers(paths: List[Dict[str, Any]]) -> Dict[str, Any]:
    """Aggregate answers using majority voting."""
    answer_counts: Dict[str, int] = {}
    for path in paths:
        ans = path["answer"]
        answer_counts[ans] = answer_counts.get(ans, 0) + 1

    majority = max(answer_counts.items(), key=lambda x: x[1])
    return {
        "final_answer": majority[0],
        "confidence": majority[1] / len(paths),
        "vote_distribution": answer_counts,
    }


def demonstrate_self_consistency() -> None:
    """Show self-consistency with multiple reasoning paths."""
    print("Part 3: Self-Consistency")
    print("-" * 50)

    question = "A farmer has 17 sheep. All but 9 run away. How many are left?"
    config = SelfConsistencyConfig(num_paths=5)

    print(f"Question: {question}")
    print(f"Generating {config.num_paths} reasoning paths...\n")

    paths = []
    for i in range(config.num_paths):
        path = generate_reasoning_path(question, i)
        paths.append(path)
        print(f"  Path {i + 1}: {path['reasoning']} -> {path['answer']}")

    result = aggregate_answers(paths)
    print(f"\nAggregation ({config.aggregation}):")
    print(f"  Distribution: {result['vote_distribution']}")
    print(f"  Final answer: {result['final_answer']} (confidence: {result['confidence']:.0%})")
    print()


# =============================================================================
# Part 4: Structured Reasoning Steps
# =============================================================================

@dataclass
class ReasoningStep:
    """A single reasoning step with explicit structure."""

    step_number: int
    action: str
    observation: str
    thought: str


@dataclass
class StructuredReasoning:
    """Structured reasoning with explicit steps."""

    question: str
    steps: List[ReasoningStep] = field(default_factory=list)
    final_answer: Optional[str] = None

    def add_step(
        self,
        action: str,
        observation: str,
        thought: str,
    ) -> "StructuredReasoning":
        """Add a reasoning step."""
        step = ReasoningStep(
            step_number=len(self.steps) + 1,
            action=action,
            observation=observation,
            thought=thought,
        )
        self.steps.append(step)
        return self

    def conclude(self, answer: str) -> "StructuredReasoning":
        """Set the final answer."""
        self.final_answer = answer
        return self

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "question": self.question,
            "steps": [
                {
                    "step": s.step_number,
                    "action": s.action,
                    "observation": s.observation,
                    "thought": s.thought,
                }
                for s in self.steps
            ],
            "final_answer": self.final_answer,
        }


def demonstrate_structured_reasoning() -> None:
    """Show structured reasoning with explicit steps."""
    print("Part 4: Structured Reasoning")
    print("-" * 50)

    reasoning = StructuredReasoning(question="What is 25% of 80?")

    # Build reasoning chain
    reasoning.add_step(
        action="Parse the problem",
        observation="Need to find 25% of 80",
        thought="I need to convert percentage to decimal and multiply",
    ).add_step(
        action="Convert percentage",
        observation="25% = 0.25",
        thought="Divide by 100 to get decimal form",
    ).add_step(
        action="Calculate",
        observation="0.25 * 80 = 20",
        thought="Multiply decimal by the number",
    ).conclude("20")

    result = reasoning.to_dict()
    print(f"Question: {result['question']}\n")
    print("Reasoning steps:")
    for step in result["steps"]:
        print(f"  Step {step['step']}:")
        print(f"    Action: {step['action']}")
        print(f"    Observation: {step['observation']}")
        print(f"    Thought: {step['thought']}")
    print(f"\nFinal answer: {result['final_answer']}")
    print()


# =============================================================================
# Part 5: Reasoning Validator
# =============================================================================

@dataclass
class ReasoningValidator:
    """Validate reasoning chains for common issues."""

    checks: List[Callable[[Dict[str, Any]], bool]] = field(default_factory=list)

    def add_check(self, check: Callable[[Dict[str, Any]], bool]) -> "ReasoningValidator":
        """Add a validation check."""
        self.checks.append(check)
        return self

    def validate(self, reasoning: Dict[str, Any]) -> Dict[str, Any]:
        """Run all validation checks."""
        results = []
        for i, check in enumerate(self.checks):
            try:
                passed = check(reasoning)
                results.append({"check": i + 1, "passed": passed})
            except Exception as e:
                results.append({"check": i + 1, "passed": False, "error": str(e)})

        all_passed = all(r["passed"] for r in results)
        return {
            "valid": all_passed,
            "checks": results,
            "passed": sum(1 for r in results if r["passed"]),
            "total": len(results),
        }


def demonstrate_reasoning_validation() -> None:
    """Show reasoning chain validation."""
    print("Part 5: Reasoning Validation")
    print("-" * 50)

    validator = ReasoningValidator()

    # Add validation checks
    validator.add_check(
        lambda r: "steps" in r and len(r["steps"]) > 0
    ).add_check(
        lambda r: r.get("final_answer") is not None
    ).add_check(
        lambda r: all("thought" in s for s in r.get("steps", []))
    )

    # Valid reasoning
    valid_reasoning = {
        "question": "Test",
        "steps": [{"action": "think", "thought": "reasoning here"}],
        "final_answer": "42",
    }

    # Invalid reasoning
    invalid_reasoning = {
        "question": "Test",
        "steps": [],
    }

    print("Validating complete reasoning:")
    result = validator.validate(valid_reasoning)
    print(f"  Valid: {result['valid']}, Passed: {result['passed']}/{result['total']}")

    print("\nValidating incomplete reasoning:")
    result = validator.validate(invalid_reasoning)
    print(f"  Valid: {result['valid']}, Passed: {result['passed']}/{result['total']}")
    print()


# =============================================================================
# Part 6: CoT Prompt Templates
# =============================================================================

COT_TEMPLATES = {
    "math": """Solve this math problem step by step.

Problem: {question}

Show your work:
1. First, identify what we're solving for
2. Set up the equation or approach
3. Perform calculations step by step
4. Verify the answer makes sense

Solution:""",
    "logic": """Analyze this logical problem carefully.

Problem: {question}

Reasoning process:
1. List the given facts
2. Identify any constraints
3. Consider each possibility
4. Eliminate contradictions
5. Arrive at conclusion

Analysis:""",
    "coding": """Break down this programming problem.

Problem: {question}

Approach:
1. Understand the inputs and expected outputs
2. Consider edge cases
3. Design the algorithm
4. Analyze time/space complexity

Solution approach:""",
}


def demonstrate_templates() -> None:
    """Show domain-specific CoT templates."""
    print("Part 6: Domain-Specific Templates")
    print("-" * 50)

    print("Available templates:")
    for domain, template in COT_TEMPLATES.items():
        # Show first few lines of each template
        lines = template.strip().split("\n")[:3]
        preview = "\n    ".join(lines)
        print(f"\n  {domain}:")
        print(f"    {preview}")
        print("    ...")
    print()

    # Apply a template
    question = "What is the sum of the first 10 positive integers?"
    formatted = COT_TEMPLATES["math"].format(question=question)
    print("Applied math template:")
    print(formatted[:200] + "...")
    print()


def main() -> None:
    """Demonstrate chain-of-thought patterns."""
    print("Chain-of-Thought Patterns")
    print("=" * 50)
    print()

    demonstrate_basic_cot()
    demonstrate_zero_shot_cot()
    demonstrate_self_consistency()
    demonstrate_structured_reasoning()
    demonstrate_reasoning_validation()
    demonstrate_templates()

    print("Key Takeaways")
    print("-" * 50)
    print("1. CoT prompting elicits step-by-step reasoning")
    print("2. Zero-shot CoT uses 'Let's think step by step'")
    print("3. Self-consistency aggregates multiple reasoning paths")
    print("4. Structured reasoning makes steps explicit and verifiable")
    print("5. Validation catches incomplete or malformed reasoning")
    print("6. Domain-specific templates improve reasoning quality")
    print()
    print("Next: See rag_pattern.py for retrieval-augmented generation")


if __name__ == "__main__":
    main()
